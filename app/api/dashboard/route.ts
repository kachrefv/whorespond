import { NextResponse } from 'next/server';import { getServerSession } from 'next-auth';import { authOptions } from '@/lib/auth';import prisma from '@/lib/prisma';export async function GET(request: Request) {  try {    const session = await getServerSession(authOptions);    if (!session) {      return new NextResponse('Unauthorized', { status: 401 });    }    const userId = session.user.id;    const today = new Date();    today.setHours(0, 0, 0, 0);    const startOfWeek = new Date(today);    startOfWeek.setDate(today.getDate() - today.getDay()); // Sunday    const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);    // Total Sales    const totalSalesToday = await prisma.order.aggregate({      _sum: { totalAmount: true },      where: {        userId,        createdAt: { gte: today },        status: { in: ['CONFIRMED', 'DELIVERED'] },      },    });    const totalSalesWeek = await prisma.order.aggregate({      _sum: { totalAmount: true },      where: {        userId,        createdAt: { gte: startOfWeek },        status: { in: ['CONFIRMED', 'DELIVERED'] },      },    });    const totalSalesMonth = await prisma.order.aggregate({      _sum: { totalAmount: true },      where: {        userId,        createdAt: { gte: startOfMonth },        status: { in: ['CONFIRMED', 'DELIVERED'] },      },    });    // Recent Orders    const recentOrders = await prisma.order.findMany({      where: { userId },      orderBy: { createdAt: 'desc' },      take: 3,      include: { orderItems: { include: { productVariant: { include: { product: true } } } } },    });    // Stock Levels (low stock)    const lowStockProducts = await prisma.productVariant.findMany({      where: {        product: { userId },        stock: { lte: 5 }, // Example threshold for low stock      },      include: { product: true },      orderBy: { stock: 'asc' },    });    // Conversion Rate    const totalConversations = await prisma.conversation.count({      where: { userId },    });    const convertedConversations = await prisma.order.count({      where: {        userId,        status: { in: ['CONFIRMED', 'DELIVERED'] },      },    });    const conversionRate = totalConversations > 0      ? (convertedConversations / totalConversations) * 100      : 0;    // Avg Order Value    const avgOrderValueResult = await prisma.order.aggregate({      _avg: { totalAmount: true },      where: {        userId,        status: { in: ['CONFIRMED', 'DELIVERED'] },      },    });    const avgOrderValue = avgOrderValueResult._avg.totalAmount || 0;    // Best Seller (Month)    const bestSellerMonth = await prisma.orderItem.groupBy({      by: ['productVariantId'],      _sum: { quantity: true },      where: {        order: {          userId,          createdAt: { gte: startOfMonth },          status: { in: ['CONFIRMED', 'DELIVERED'] },        },      },      orderBy: { _sum: { quantity: 'desc' } },      take: 1,    });    let bestSellerProduct = null;    if (bestSellerMonth.length > 0) {      const variant = await prisma.productVariant.findUnique({        where: { id: bestSellerMonth[0].productVariantId },        include: { product: true },      });      bestSellerProduct = variant?.product.name;    }    // Canceled Orders    const canceledOrdersCount = await prisma.order.count({      where: {        userId,        status: 'CANCELED',      },    });    return NextResponse.json({      sales: {        today: totalSalesToday._sum.totalAmount || 0,        week: totalSalesWeek._sum.totalAmount || 0,        month: totalSalesMonth._sum.totalAmount || 0,      },      recentOrders: recentOrders.map(order => ({        id: order.id,        customerName: order.customerName,        productName: order.orderItems[0]?.productVariant.product.name || 'N/A',        totalAmount: order.totalAmount,        status: order.status,      })),      stockLevels: lowStockProducts.map(pv => ({        id: pv.id,        name: `${pv.product.name} - ${pv.color ? pv.color + ' ' : ''}${pv.size ? pv.size : ''}`.trim(),        stock: pv.stock,        isLow: pv.stock <= 5,      })),      keyMetrics: {        conversionRate: parseFloat(conversionRate.toFixed(1)),        avgOrderValue: parseFloat(avgOrderValue.toFixed(2)),        bestSellerMonth: bestSellerProduct,        canceledOrders: canceledOrdersCount,      },    });  } catch (error) {    console.error('Error fetching dashboard data:', error);    return new NextResponse('Internal Server Error', { status: 500 });  }}