import { NextResponse } from 'next/server';import { getServerSession } from 'next-auth';import { authOptions } from '@/lib/auth';import prisma from '@/lib/prisma';export async function GET(request: Request, { params }: { params: { id: string } }) {  try {    const session = await getServerSession(authOptions);    if (!session) {      return new NextResponse('Unauthorized', { status: 401 });    }    const { id } = params;    const messages = await prisma.message.findMany({      where: { conversationId: id },      orderBy: { createdAt: 'asc' },    });    return NextResponse.json(messages);  } catch (error) {    console.error('Error fetching messages:', error);    return new NextResponse('Internal Server Error', { status: 500 });  }}export async function POST(request: Request, { params }: { params: { id: string } }) {  try {    const session = await getServerSession(authOptions);    if (!session) {      return new NextResponse('Unauthorized', { status: 401 });    }    const { id } = params;    const { senderType, content } = await request.json();    if (!senderType || !content) {      return new NextResponse('Missing required fields: senderType, content', { status: 400 });    }    // Ensure the conversation belongs to the user    const conversation = await prisma.conversation.findUnique({      where: { id, userId: session.user.id },    });    if (!conversation) {      return new NextResponse('Conversation not found or unauthorized', { status: 404 });    }    const message = await prisma.message.create({      data: {        conversationId: id,        senderType,        content,      },    });    // Update lastMessageAt for the conversation    await prisma.conversation.update({      where: { id },      data: { lastMessageAt: new Date() },    });    return NextResponse.json(message, { status: 201 });  } catch (error) {    console.error('Error creating message:', error);    return new NextResponse('Internal Server Error', { status: 500 });  }}